<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>

<title>Fundamentals of CLOS</title>

</head>

<body bgcolor="#FFFFFF" text="#000000" link="#000099" vlink="#660066" alink="#FF0000">

<div align="center">

<p>
<a href="http://www.ravenbrook.com/">Ravenbrook</a> /
<a href="http://www.international-lisp-conference.org/">ILC 2003</a>
</p>

<hr />


<h1>Fundamentals of CLOS</h1>

<address>
<a href="mailto:ndl@ravenbrook.com">Nick Levine</a>,
<a href="http://www.ravenbrook.com/">Ravenbrook Limited</a>,
2003-07-15
</address>

</div>


<h2><a id="section-1" name="section-1">1. Introduction</a></h2>

<p>This document was written for presentation during a tutorial
session at the <a
href="http://www.international-lisp-conference.org/">International
Lisp Conference</a> held in New York City in October 2003.</p>

<p>The intended audience for the tutorial is anybody with a basic
knowledge of lisp or scheme, who wants to know something about how to
use the "Common Lisp Object System" (CLOS). However, in an attempt to
provide something for everyone, the tutorial will cover:</p>

<ul>

<li><p>an introduction to the 10% of CLOS which you need to get you
through 90% of use cases;</p></li>

<li><p>a number of opinionated statements, for instance about the
differences between CLOS and other object systems;</p></li>

<li><p>a brief look "under the hood" at how some of the more dynamic
features of CLOS might be implemented;</p></li>

<li><p>some exercises.</p></li>

</ul>

<p>The <a href="http://www.nicklevine.org/">author</a> worked on the
LispWorks project at Harlequin for ten years. Since then he has <a
href="http://www.fast-index.com/declarative/lectures/">taught lisp</a>
to undergraduates, written an <a
href="http://www.fast-index.com/">open-source search engine</a>, and
taken up the stress-free existence of a <a
href="http://www.franz.com/careers/resumes/nlevine.lhtml">software
consultant</a>.</p>

<p>The examples in this tutorial are available in a separate file <a
href="examples.lisp">examples.lisp</a>. I hope to use the code in <a
href="present.lisp">present.lisp</a> to squirt them into a lisp
listener during the tutorial.</p>

<p>This document is not confidential. It is available on the web, at
<a
href="http://www.ravenbrook.com/doc/2003/07/15/clos-fundamentals/">http://www.ravenbrook.com/doc/2003/07/15/clos-fundamentals/</a>.</p>


<h2><a id="section-2" name="section-2">2. Background</a></h2>

<p><cite>CLOS</cite> (either one syllable rhyming with "dross", or two
syllables as in "see-loss") is the "Common Lisp Object System". The
functionality belonging to this name was added to the Common Lisp
language between the publication of Steele's first edition of "Common
Lisp, the Language" in 1984 and the formalization of the language as
an ANSI standard ten years later.</p>

<p>The source material for CLOS was a report written in three
chapters. The first two, consisting of "Programmer Interface Concepts"
and "Functions in the Programmer Interface", will now be found as the
two halves of chapter 28 in [Steele 1990] and were the basis for
relevant parts of the ANSI specification when it later appeared. The
third chapter, on the Metaobject protocol, was regarded (by its
authors, I believe) as incomplete and never published.</p>

<p>This tutorial is also incomplete, but in a different sense: I have
deliberately omitted as much as I could. CLOS offers many alternate
styles of working, as well as - in some considerable detail - a number
of opportunities for applications to extend and reconfigure CLOS
itself. (Some of this detail will be covered in the following
tutorial, on the "Metaobject Protocol".) The intention of this
tutorial is to provide a sufficient grounding in the (say) 10% of CLOS
which covers 90% of use cases - enough to get a novice off the
ground. We will access this 10% by examining in some (but not full!)
detail two defining macros: <a
href="#section-3"><code>defclass</code></a> and <a
href="#section-4"><code>defmethod</code></a>.</p>

<p>As to what an <cite>object system</cite> is: I can only say that by
the end of this tutorial you should have some idea of what CLOS has to
offer. (Is it just a collection of 33 functions, 8 macros and some
interesting new types? Or is it something more profound?)
Historically, and implementationally, all the concepts here are
strongly related. However, when you come to use them yourself you'll
find that in an application the relation is not so strong, and you can
pick and choose what's useful to you and leave alone what isn't.</p>


<h3><a id="section-2.1" name="section-2.1">2.1. References</a></h3>

<p>These are listed in <a href="#section-A">appendix A</a> at the end
of this document. [Keene 1989] is a very easy introduction and more
thorough than the single chapter in [Graham 1995], but it will
obviously take you longer to read. [Steele 1990, otherwise known as
"CLtl2"] is a handy reference guide, but do take a little care because
it predates the ANSI specification - for which see the "hyperspec"
[Pitman 1996] - and differs in some important respects (for a list of
which see the end of appendix C in [Graham 1995). A (note: not "the")
metaobject protocol, described in [Kiczales et al 1991, otherwise
known as "AMOP"], gives many hints about configuration and
implementation.</p>



<h3><a id="section-2.2" name="section-2.2">2.2. Getting started</a></h3>

<p>Theoretically this should not be an issue in any fully enabled
Common Lisp, because CLOS is part of the language. However, some
implementations might expect you to <code>(require "clos")</code> or
similar. Check your manual.</p>

<p>Most of the examples in this tutorial should work fine in any
package which "uses" <code>COMMON-LISP</code>, and they should port to
any conforming implementation. The exceptions are marked as such.  I
have tested the examples in LispWorks (version 4.2.7, used to generate
all the examples below) and Allegro CL (version 6.2).</p>


<h2><a id="section-3" name="section-3">3. Classes and instances</a></h2>


<h3><a id="section-3.1" name="section-3.1">3.1. Review - the non-OO approach</a></h3>

<p>Before we introduce the first of our two defining macros, let's
review its non object-oriented equivalent: <code>defstruct</code>. The
language provides you with a number of specialized data types
(<code>cons</code>, <code>string</code>, <code>hash-table</code>,
etc.) along with this mechanism for defining your own structures. An
example:</p>

<blockquote><pre>
(defstruct point
  x
  y
  z)
</pre></blockquote>

<p>The form is roughly equivalent to a struct declaration in C. It
defines a new type, called <code>point</code>, with three
<cite>slots</cite> (or <cite>fields</cite> if that's a word you're
happier with) called <code>x</code>, <code>y</code> and
<code>z</code>.</p>

<p>Compactly, the above invocation of <code>defstruct</code> gives us
all of the following:</p>

<ul>

<li><p>A <cite>constructor</cite> function <code>make-point</code>,
which takes keyword arguments <code>:x</code> <code>:y</code> and
<code>:z</code> (all defaulting to <code>nil</code> if not
supplied). Every time you call this function a new <code>point</code>
is allocated and returned.</p></li>

<li><p>Any object returned by <code>make-point</code> will be of type
<code>point</code>, and will respond enthusiastically to the
<cite>predicate</cite> <code>point-p</code>.</p></li>

<li><p>Setfable <cite>accessors</cite> <code>point-x</code>,
<code>point-y</code> and <code>point-z</code> can be used to read and
modify the slots of any <code>point</code> object.</p></li>

<li><p>A shallow <cite>copier</cite>,
<code>copy-point</code>.</p></li>

</ul>

<p>Structures can have any number of slots, from zero up (to some
implementation-defined limit, e.g. 254 in LispWorks for Windows) and -
as with lists and general vectors - the slots can hold any values.</p>

<p>In this example, <strong>note</strong> the form in which structures
are printed by default, and which can be parsed by the lisp
reader.</p>


<blockquote><pre>
CL-USER 1 &gt; (defstruct point
              x
              y
              z)
POINT

CL-USER 2 &gt; (defun distance-from-origin (point)
              (let* ((x (point-x point))
                     (y (point-y point))
                     (z (point-z point)))
                (sqrt (+ (* x x) (* y y) (* z z)))))
DISTANCE-FROM-ORIGIN

CL-USER 3 &gt; (defun reflect-in-y-axis (point)
              (setf (point-y point)
                    (- (point-y point))))
REFLECT-IN-Y-AXIS

CL-USER 4 &gt; (setf my-point (make-point :x 3 :y 4 :z 12))
#S(POINT X 3 Y 4 Z 12)

CL-USER 5 &gt; (type-of my-point)
POINT

CL-USER 6 &gt; (distance-from-origin my-point)
13.0

CL-USER 7 &gt; (reflect-in-y-axis my-point)
-4

CL-USER 8 &gt; my-point
#S(POINT X 3 Y -4 Z 12)

CL-USER 9 &gt; (setf a-similar-point #s(point :x 3 :y -4 :z 12))
#S(POINT X 3 Y -4 Z 12)

CL-USER 10 &gt; (equal my-point a-similar-point)
NIL

CL-USER 11 &gt; (equalp my-point a-similar-point)
T

CL-USER 12 &gt;
</pre></blockquote>

<p><strong>Note</strong> that <code>defstruct</code> has a number of
options (which we won't cover here), for describing inheritance,
printing behaviour, slot types and defaults, and so on.</p>


<h3><a id="section-3.2" name="section-3.2">3.2. Introducing the macro <code>defclass</code></a></h3>


<p>The macro used for defining new data types in CLOS is
<code>defclass</code>. An example:</p>

<blockquote><pre>
(defclass point ()
  (x
   y
   z))
</pre></blockquote>

<p><strong>Note</strong> but ignore the empty parentheses for
now. <strong>Note</strong> also the parentheses around the set of slot
names (unlike <code>defstruct</code>). The above invocation gives us
the following (and no more):</p>

<ul>

<li><p>A CLOS type (or <cite>class</cite>) named <code>point</code>.</p></li>

<li><p>Three slots in this class, again named <code>x</code>,
<code>y</code> and <code>z</code>.</p></li>

</ul>

<p><strong>Note</strong> that - unlike <code>defstruct</code> above -
<code>defclass</code> gives us <u>none</u> of the following:
constructor, predicate, accessors (unless we ask for them explicitly -
see <a href="#section-3.5">section 3.5</a> below), copier,
<code>#s</code> <code>print</code> / <code>read</code> syntax. You can
generate similar functionality in CLOS, but it doesn't come
automatically the way it did with structures. Quite often, you'll find
that you don't need the power of CLOS and that <code>defstruct</code>
is more than enough to meet your needs, not to mention being more
convenient. When I'm writing an application, I typically start by
defining my types with <code>defstruct</code>, and only change them to
<code>defclass</code> when it becomes necessary to do so.</p>

<p><strong>Note</strong> next that if a type has previously been
defined as a structure, then you can't redefine it as a class. (On the
other hand, "the consequences of redefining a defstruct structure are
undefined" so we shouldn't feel we're losing out.) We'll sneak around
that in this session by <code>unintern</code>ing the name of the old
type:</p>

<blockquote><pre>
CL-USER 12 &gt; (unintern 'point)
T

CL-USER 13 &gt; (defclass point ()
               (x
                y
                z))
#&lt;STANDARD-CLASS POINT 2060C12C&gt;

CL-USER 14 &gt; (setf my-point (make-instance 'point))
#&lt;POINT 205FA53C&gt;

CL-USER 15 &gt; (type-of my-point)
POINT

CL-USER 16 &gt; (defun set-point-values (point x y z)
               (setf (slot-value point 'x) x
                     (slot-value point 'y) y
                     (slot-value point 'z) z))
SET-POINT-VALUES

CL-USER 17 &gt; (set-point-values my-point 3 4 12)
12

CL-USER 18 &gt; (defun distance-from-origin (point)
               (with-slots (x y z)
                   point
                 (sqrt (+ (* x x) (* y y) (* z z)))))
DISTANCE-FROM-ORIGIN

CL-USER 19 &gt; (distance-from-origin my-point)
13.0

CL-USER 20 &gt;
</pre></blockquote>

<p><strong>Note</strong> the following:</p>

<ul>

<li><p>The use of <code>make-instance</code> to allocate an
<cite>instance</cite> of our new class.</p></li>

<li><p>The "unreadable" printed representation of
<code>my-point</code> in line 14.</p></li>

<li><p>The setfable function <code>slot-value</code> used to access
values in an instance's slots.</p></li>

<li><p>The macro <code>with-slots</code>, for abbreviating calls to
<code>slot-value</code>. The first argument is a list of slot
names. The second argument evaluates to a CLOS instance; this is
followed by optional declarations and an implicit
<code>progn</code>. Lexically during the evaluation of the body, an
access to any of these names as a variable is equivalent to accessing
the corresponding slot of the CLOS instance.</p></li>

</ul>

<p><strong>Exercise:</strong> Rewrite <code>set-point-values</code>
using <code>with-slots</code>.</p>

<p><strong>Exercise:</strong> Use <code>symbol-macrolet</code> to
implement <code>with-slots</code>. Note that each name listed in the
first argument to <code>symbol-macrolet</code> can be replaced by the
pair <cite>(variable-name slot-name)</cite>.</p>

<p><strong>Exercise:</strong> Write a macro <code>defclass-plus</code>
which expands into a <code>defclass</code> plus some or all of the
following, in the spirit of <code>defstruct</code>: constructor,
predicate, accessors and copier. This may get tedious, in which case
convince yourself that you know what you're doing and then stop.</p>



<h3><a id="section-3.3" name="section-3.3">3.3. Classes are instances too</a></h3>

<p>Compare the values returned from the example calls to
<code>defstruct</code> (line 1 above) and <code>defclass</code> (line
13). The former doesn't return anything useful, but the latter has
returned a lisp object of some sort: <code>#&lt;STANDARD-CLASS POINT
275B78DC&gt;</code>. This object <u>is</u> the class named
<code>point</code>. It's a first class object within lisp: an
embodiment of a CLOS type. In fact it can be passed as the type
argument to <code>typep</code> and <code>subtypep</code>. It's also a
CLOS object, which means it must be an instance of a CLOS class, and
we can find out what that class is, as in the example below.</p>

<blockquote><pre>
CL-USER 20 &gt; (find-class 'point)
#&lt;STANDARD-CLASS POINT 275B78DC&gt;

CL-USER 21 &gt; (class-name (find-class 'point))
POINT

CL-USER 22 &gt; (class-of my-point)
#&lt;STANDARD-CLASS POINT 275B78DC&gt;

CL-USER 23 &gt; (typep my-point (class-of my-point))
T

CL-USER 24 &gt; (class-of (class-of my-point))
#&lt;STANDARD-CLASS STANDARD-CLASS 20306534&gt;

CL-USER 25 &gt;
</pre></blockquote>

<p>The last of these looks a little scary at first. The object
<code>my-point</code> is an instance of the class named
<code>point</code>; the class named <code>point</code> is itself an
instance of the class named <code>standard-class</code>. We say that
the class named <code>standard-class</code> is the
<cite>metaclass</cite> (i.e. the class of the class) of
<code>my-point</code>.</p>

<p><strong>Notation:</strong> describing something as "the class named
<code>standard-class</code>" may be correct but it doesn't make for
elegant reading. When we refer to "the class
<code>standard-class</code>" or even to <code>standard-class</code>,
we generally mean the class named by that symbol.</p>



<h3><a id="section-3.4" name="section-3.4">3.4. You don't need CLOS objects to use CLOS</a></h3>

<p>Generously, the functions introduced in the last section also work
on lisp objects which are <u>not</u> CLOS instances:</p>

<blockquote><pre>
CL-USER 25 &gt; (let ((the-symbol-class (find-class 'symbol)))
               (values the-symbol-class
		       (class-name the-symbol-class)
                       (eq the-symbol-class (class-of 'symbol))
		       (class-of the-symbol-class)))
#&lt;BUILT-IN-CLASS SYMBOL 20306474&gt;
SYMBOL
T
#&lt;STANDARD-CLASS BUILT-IN-CLASS 20306414&gt;

CL-USER 26 &gt;
</pre></blockquote>

<p>Postponing to <a href="#section-4.5">section 4.5</a> the question
of why this might be useful to us, we see here that lisp
<code>symbol</code>s are instances of the system class
<code>symbol</code>. This is one of 75 cases in which the language
requires a class to exist with the same name as the corresponding lisp
type. Many of these cases are concerned with CLOS itself (for example,
the correspondence between the type <code>standard-class</code> and
the CLOS class of that name) or with the condition system (which might
or might not be built using CLOS classes in any given
implementation). However, 33 correspondences remain relating to
"traditional" lisp types:</p>

<blockquote><table>
<tr><td><code>array</code></td>		<td><code>hash-table</code></td>	<td><code>readtable</code></td></tr>
<tr><td><code>bit-vector</code></td>	<td><code>integer</code></td>		<td><code>real</code></td></tr>
<tr><td><code>broadcast-stream</code></td>
					<td><code>list</code></td>		<td><code>sequence</code></td></tr>
<tr><td><code>character</code></td>	<td><code>logical-pathname&nbsp;&nbsp;</code></td>
										<td><code>stream</code></td></tr>
<tr><td><code>complex</code></td>	<td><code>null</code></td>		<td><code>string</code></td></tr>
<tr><td><code>concatenated-stream&nbsp;&nbsp;</code></td>
					<td><code>number</code></td>		<td><code>string-stream</code></td></tr>
<tr><td><code>cons</code></td>		<td><code>package</code></td>		<td><code>symbol</code></td></tr>
<tr><td><code>echo-stream</code></td>	<td><code>pathname</code></td>		<td><code>synonym-stream</code></td></tr>
<tr><td><code>file-stream</code></td>	<td><code>random-state</code></td>	<td><code>t</code></td></tr>
<tr><td><code>float</code></td>		<td><code>ratio</code></td>		<td><code>two-way-stream</code></td></tr>
<tr><td><code>function</code></td>	<td><code>rational</code></td>		<td><code>vector</code></td></tr>
</table></blockquote>

<p><strong>Note</strong> that not all "traditional" lisp types are
included in this list. (Consider: <code>atom</code>,
<code>fixnum</code>, <code>short-float</code>, and any type not
denoted by a symbol.)
</p>

<p>The presence of <code>t</code> is interesting. Just as every lisp
object is of type <code>t</code>, every lisp object is also a member
of the class named <code>t</code>. This is a simple example of
membership of more then one class at a time, and it brings into
question the issue of <cite>inheritance</cite>, which we will consider
in some detail later (<a href="#section-3.6">section 3.6</a>).</p>

<blockquote><pre>
CL-USER 26 &gt; (find-class t)
#&lt;BUILT-IN-CLASS T 20305AEC&gt;

CL-USER 27 &gt;
</pre></blockquote>

<p>In addition to classes corresponding to lisp types, there is also a
CLOS class for every structure type you define:</p>

<blockquote><pre>
CL-USER 27 &gt; (defstruct foo)
FOO

CL-USER 28 &gt; (class-of (make-foo))
#&lt;STRUCTURE-CLASS FOO 21DE8714&gt;

CL-USER 29 &gt;
</pre></blockquote>

<p>The metaclass of a <code>structure-object</code> is the class
<code>structure-class</code>. It is implementation-dependent whether
the metaclass of a "traditional" lisp object is
<code>standard-class</code> (as in <a href="#section-3.3">section
3.3</a>), <code>structure-class</code>, or
<code>built-in-class</code>. Restrictions:</p>

<table border="1" cellpadding="10">

<tr valign="top">
<td><code>built-in-class</code></td>
<td>May not use <code>make-instance</code>, may not use
<code>slot-value</code>, may not use <code>defclass</code> to modify,
may not create subclasses.</td>
</tr>

<tr valign="top">
<td><code>structure-class</code></td> <td>May not use
<code>make-instance</code>, might work with <code>slot-value</code>
(implementation-dependent). Use <code>defstruct</code> to subclass
application structure types. Consequences of modifying an existing
<code>structure-class</code> are undefined: full recompilation may be
necessary.</td>
</tr>

<tr valign="top">
<td><code>standard-class</code></td>
<td>None of these restrictions.</td>
</tr>

</table>


<h3><a id="section-3.5" name="section-3.5">3.5. Slots</a></h3>

<p>The full syntax for <code>defclass</code> is:</p>

<blockquote><code><strong>defclass</strong></code> <cite>class-name ({superclass-name}*) ({slot-specifier}*) [[class-option]]</cite></blockquote>

<p>We'll discuss the second argument in <a href="#section-3.6">section
3.6</a> below. <cite>Class-options</cite> are outside the scope of
this tutorial. In this section, we'll take a look at the
<cite>slot-specifiers</cite>.</p>

<p>In the class definition of <code>point</code> above, each slot was
specified simply by its name. We can instead specify a slot thus:</p>

<blockquote><cite>(slot-name [[slot-option]])</cite></blockquote>

<p>Each <cite>slot-option</cite> consists of a keyword followed by a
value. Among the keywords available are the following; you can specify
as many or few as you need. Three of these keywords
(<code>:accessor</code>, <code>:reader</code> and
<code>:initarg</code>) may appear more than once for each slot, if you
like.</p>

<table border="1" cellpadding="10">

<tr valign="top"><td><p><code>:accessor</code></p></td>

<td><p>Defines <cite>methods</cite> (see <a href="#section-4">section
4</a> below, think of them as functions for the time being), named by
the given value, for reading and modifying the slot. For example,
<code>:accessor point-x</code> defines the functions
<code>point-x</code> and <code>(setf point-x)</code>. Using accessors
is a Good Idea, because:</p>

<ul>

<li>you can use them as part of a documented interface without
committing yourself to implementing the interface by means of a
<code>slot-value</code> access in future;</li>

<li>you are rewarded for using them by having code that's simpler and
more compact.</li>

</ul></td>

</tr>

<tr valign="top"><td><p><code>:reader</code></p></td>

<td><p>Defines a single method for reading the slot; a read-only
counterpart to <code>:accessors</code>.</p></td>

</tr>

<tr valign="top"><td><p><code>:initarg</code></p></td>

<td><p>Specifies a keyword which can be used to pass an initial value
for this slot to <code>make-instance</code> (an <cite>initialization
argument</cite>).</p></td>

</tr>

<tr valign="top"><td><p><code>:initform</code></p></td>

<td><p>Specifies a default value for this slot, to be used if no
initial value was specified explicitly. This form is evaluated each
time it's needed, in the lexical environment of the
<code>defclass</code>.</p></td>

</tr>

<tr valign="top"><td><p><code>:allocation</code></p></td>

<td><p>Specifies whether the value of this slot:</p>

<ul>

<li>can be different for each instance of the class (<code>:allocation
:instance</code> - the default - resulting in a <cite>local
slot</cite>); or</li>

<li>is shared between all instances of the class (<code>:allocation
:class</code> - resulting in a <cite>class slot</cite>).</li>

</ul></td>

</tr>

</table>

<p>In the following example, <strong>note</strong> the following:</p>

<ul>

<li><p>the specification and use of the <code>:x</code> initialization
argument for the slot <code>x</code>;</p></li>

<li><p>the default value for the slot <code>y</code>;</p></li>

<li><p>how changing the value of the class slot <code>z</code> - but
not the local slots - affects all instances of the class (whether or
not those instances exist yet);</p></li>

<li><p>the stylistic difference in line 33 between using an accessor
(<code>daft-y</code>) and <code>slot-value</code>.</p></li>

</ul>


<blockquote><pre>
CL-USER 29 &gt; (defclass daft-point ()
               ((x :accessor daft-x :initarg :x)
                (y :accessor daft-y :initform 3.14159)
                (z :reader daft-z :allocation :class)))
#&lt;STANDARD-CLASS DAFT-POINT 21DF867C&gt;

CL-USER 30 &gt; (setf (slot-value (make-instance 'daft-point) 'z) 42)
42

CL-USER 31 &gt; (setf my-daft-point (make-instance 'daft-point :x 19))
#&lt;DAFT-POINT 205F264C&gt;

CL-USER 32 &gt; (list (daft-x my-daft-point)
                   (daft-y my-daft-point)
                   (daft-z my-daft-point))
(19 3.14159 42)

CL-USER 33 &gt; (let ((temp (make-instance 'daft-point)))
               (setf (daft-y temp) 999
	             (slot-value temp 'z) 0))
0

CL-USER 34 &gt; (list (daft-x my-daft-point)
                   (daft-y my-daft-point)
                   (daft-z my-daft-point))
(19 3.14159 0)

CL-USER 35 &gt;
</pre></blockquote>

<p><strong>Exercise:</strong> Find a <code>defstruct</code> form and
"port to CLOS" one of its slot options (or more if they're
interesting).</p>


<h3><a id="section-3.6" name="section-3.6">3.6. Subclasses and inheritance</a></h3>

<p>Suppose we want two classes to share behaviour, in the sense that
one of them (the <cite>subclass</cite>) is defined in terms of the
other (the <cite>superclass</cite>). This leads us to the notion of
<cite>inheritance</cite>, common in some form to all object
systems.</p>

<p>For example:</p>

<blockquote><pre>
CL-USER 35 &gt; (defclass animal ()
               ((legs :reader leg-count :initarg :legs)
                (comes-from :reader comes-from :initarg :comes-from)))
#&lt;STANDARD-CLASS ANIMAL 2150BA0C&gt;

CL-USER 36 &gt; (defclass mammal (animal)
               ((diet :initform 'antelopes :initarg :diet)))
#&lt;STANDARD-CLASS MAMMAL 2150A894&gt;

CL-USER 37 &gt; (defclass aardvark (mammal)
               ((cute-p :accessor cute-p :initform nil)))
#&lt;STANDARD-CLASS AARDVARK 2150A5D4&gt;

CL-USER 38 &gt;
</pre></blockquote>

<p>In this example, <code>mammal</code> is defined (by line 36) to be
a subclass of <code>animal</code>. This means that every instance of
<code>mammal</code> is also an instance of <code>animal</code>. If we
<code>(make-instance 'mammal)</code>, we get an object with three
slots: <code>diet</code> which comes directly from the definition of
<code>mammal</code>, plus <code>legs</code> and
<code>comes-from</code> which are both <cite>inherited</cite> from the
definition of <code>animal</code>.</p>

<p>Similarly, every <code>aardvark</code> is both a
<code>mammal</code> and an <code>animal</code>, and has four slots,
three of which are inherited from superclasses. <strong>Note</strong>
that the subclass relationship is <cite>transitive</cite> -
<code>aardvark</code> is an (<cite>indirect</cite>) subclass of
<code>animal</code>, via <code>mammal</code>. Therefore you do not
need to explicitly list <code>animal</code> as a superclass of
<code>aardvark</code>.</p>

<div align="center">
<img src="images/fig-1.gif"
     alt="Aardvark is a subclass of mammal, which is a subclass of animal"
     height="199" width="269" />
<p><a id="figure-1" name="figure-1">
Figure 1. <code>Aardvark</code> is a subclass of <code>mammal</code>
which is a subclass of <code>animal</code></a>. The arrows denote the
<cite>superclass</cite> relationship.</p>
</div>

<p>In CLOS, these relationships can be queried by the readers
<code>class-direct-superclasses</code> and
<code>class-precedence-list</code>. (<strong>Implementation
note:</strong> these two functions are not part of Common Lisp. In
LispWorks they're available via your default
<code>package-use-list</code>, in Allegro they're exported from
<code>ACLMOP</code>. Also in Allegro, you have to have made an
instance of <code>aardvark</code> before you can interrogate its
precedence list.) </p>

<blockquote><pre>
CL-USER 38 &gt; (class-direct-superclasses (find-class 'aardvark))
(#&lt;STANDARD-CLASS MAMMAL 2150A894&gt;)

CL-USER 39 &gt; (class-precedence-list (find-class 'aardvark))
(#&lt;STANDARD-CLASS AARDVARK 2150A5D4&gt; #&lt;STANDARD-CLASS MAMMAL 2150A894&gt;
 #&lt;STANDARD-CLASS ANIMAL 2150BA0C&gt; #&lt;STANDARD-CLASS STANDARD-OBJECT 20305B4C&gt;
 #&lt;BUILT-IN-CLASS T 20305AEC&gt;)

CL-USER 40 &gt;
</pre></blockquote>

<p>The <code>class-precedence-list</code> of a class is a list which
starts from that class and recursively shows superclasses, in
order. The first three elements in the above list come as no surprise
but the other two merit brief discussion.</p>

<ul>

<li><p>All CLOS objects (anything allocated by calling
<code>make-instance</code>) are instances of the system class
<code>standard-object</code>. In other words, all instances of
<code>standard-class</code>es inherit from
<code>standard-object</code>. You do not ever have to list
<code>standard-object</code> as a superclass because it's there
implicitly. <code>(defclass foo () ())</code> and <code>(defclass foo
(standard-object) ())</code> are the same.</p></li>

<li><p>All classes are subclasses of the class named <code>t</code>,
which we introduced in <a href="#section-3.4">section 3.4</a>
above.</p></li>

</ul>

<div align="center">
<img src="images/fig-2.gif"
     alt="Class precedence for aardvark"
     height="337" width="136" />
<p><a id="figure-2" name="figure-2">
Figure 2. Class precedence for <code>aardvark</code></a></p>
</div>



<p>Now consider this:</p>

<blockquote><pre>
CL-USER 40 &gt; (defclass figurine ()
               ((potter :accessor made-by :initarg :made-by)
                (comes-from :initarg :made-in)))
#&lt;STANDARD-CLASS FIGURINE 205FBD1C&gt;

CL-USER 41 &gt; (defclass figurine-aardvark (aardvark figurine)
               ((name :reader aardvark-name :initarg :aardvark-name)
                (diet :initform nil)))
#&lt;STANDARD-CLASS FIGURINE-AARDVARK 205FF354&gt;

CL-USER 42 &gt;
</pre></blockquote>

<p>The class <code>figurine-aardvark</code> here inherits its
behaviour from <u>two</u> direct superclasses. Any instance of this
class will therefore also be an instance of each of these two classes,
and of all their superclasses.</p>

<div align="center">
<img src="images/fig-3.gif"
     alt="Figurine-aardvark inherits from two direct superclasses"
     height="406" width="193" />
<p><a id="figure-3" name="figure-3">
Figure 3. <code>Figurine-aardvark</code> inherits from two direct
superclasses</a></p>
</div>


<p>This is called <cite>multiple inheritance</cite>. It's a terribly
useful feature of CLOS. Not all OO systems support it. For example,
consider <code>implements</code> in Java, where you can have full
inheritance from no more than one superclass and a highly restricted
form of inheritance from any others. Multiple inheritance in CLOS is
symmetric between as many superclasses as you want to specify. Ensure
that the OO system you're using supports full multiple
inheritance.</p>

<p><strong>Note that</strong>, because every CLOS class inherits from
<code>standard-object</code>, a feature of multiple inheritance is the
presence of "loops" in the class inheritance diagram. Calculating the
precedence list is no longer straightforward (look up
<cite>topological sorting</cite>), but it's worth knowing that the
result has to be compatible with (a) the order of explicitly named
superclasses and (b) the class precedence lists of all
superclasses.</p>

<blockquote><pre>
CL-USER 42 &gt; (class-precedence-list (find-class 'figurine-aardvark))
(#&lt;STANDARD-CLASS FIGURINE-AARDVARK 2150938C&gt; #&lt;STANDARD-CLASS AARDVARK 2150A5D4&gt;
 #&lt;STANDARD-CLASS MAMMAL 2150A894&gt; #&lt;STANDARD-CLASS ANIMAL 2150BA0C&gt;
 #&lt;STANDARD-CLASS FIGURINE 2150A06C&gt; #&lt;STANDARD-CLASS STANDARD-OBJECT 20305B4C&gt;
 #&lt;BUILT-IN-CLASS T 20305AEC&gt;)

CL-USER 43 &gt;
</pre></blockquote>


<p>Let's now turn to look at the slots of
<code>figurine-aardvark</code>:</p>

<ul>

<li><code>legs</code> - inherited from <code>animal</code>;</li>

<li><code>comes-from</code> - inherited from <code>animal</code> and
<code>figurine</code>;</li>

<li><code>diet</code> - inherited from <code>mammal</code>, also a
direct slot in <code>figurine-aardvark</code>;</li>

<li><code>cute-p</code> - inherited from <code>aardvark</code>;</li>

<li><code>potter</code> - inherited from <code>figurine</code>;</li>

<li><code>name</code> - direct slot in
<code>figurine-aardvark</code>.</li>

</ul>

<p>What happens if a slot with some given name appears more than once
in the precedence list? The answer is that the subclass ends up with
only one slot of that name, and that slot's properties are a
combination of the properties of the slots which it inherited. The
rules for combining each option are as follows:</p>

<ul>

<li><p><code>:accessor</code> and <code>:reader</code> - the union of
accessors / readers from all the inherited slots; see <a
href="#section-4">section 4</a> below for the sense in which this
works if names are repeated.</p></li>

<li><p><code>:initarg</code> - the union of initialization arguments
from all the inherited slots. For example, the valid
<code>:initarg</code>s for the <code>comes-from</code> slot in
<code>figurine-aardvark</code> are <code>:comes-from</code> and
<code>:made-in</code>.</p></li>

<li><p><code>:initform</code> - the most <cite>specific</cite> default
initial value form (i.e. the first <code>:initform</code> for that
slot in the precedence list). For example, the <code>:initform</code>
for a <code>figurine-aardvark</code>'s <code>diet</code> is
<code>nil</code>.</p></li>

<li><p><code>:allocation</code> - not inherited; controlled solely by
the class being defined; defaults to <code>:instance</code>.</p></li>

</ul>

<p>Example:</p>

<blockquote><pre>
CL-USER 43 &gt; (setf Eric (make-instance 'figurine-aardvark
                                       :legs 4
                                       :made-by "Jen"
                                       :made-in "Brittany"
                                       :aardvark-name "Eric"))
#&lt;FIGURINE-AARDVARK 206108BC&gt;

CL-USER 44 &gt; (shiftf (cute-p Eric) t)
NIL

CL-USER 45 &gt; (slot-value Eric 'diet)
NIL

CL-USER 46 &gt;
</pre></blockquote>

<p>Be warned that inheritance is fairly easy to misuse, and multiple
inheritance is multiply so, so please take a little care. Ask yourself
whether <code>foo</code> really wants to inherit from
<code>bar</code>, or whether instances of <code>foo</code> want a slot
containing a <code>bar</code>. A good general guide is that if
<code>foo</code> and <code>bar</code> are "same sort of thing" then
it's correct to mix them together by inheritance, but if they're
really separate concepts then you should use slots to keep them
apart.</p>

<p>For instance, suppose your application wants to draw a picture of a
traffic light. The class <code>drawable-traffic-light</code> probably
wants to inherit from <code>drawable</code> and to have a slot
pointing to each instance's <code>traffic-light</code>. Mixing the
classes together with this flashy multiple inheritance stuff will just
lead to <a
href="http://www.cogsci.princeton.edu/cgi-bin/webwn1.7.1?stage=1&amp;word=spaghetti">spaghetti</a>.
If following your code depends on an intimate understanding of how
topological sorting works, or detailed examination of many classes to
figure out why you didn't get the <code>:initform</code> you wanted,
then you've overdone it by a long way. Back off.</p>

<p><strong>Exercise:</strong> For which features of
<code>defstruct</code> have we not yet covered the CLOS
counterparts?</p>

<p><strong>Exercise:</strong> Take an application which uses
structures, rewrite it using <code>defclass</code>, and get it working
again.</p>

<p><strong>Exercise:</strong> Use your lisp implementation, to take a
look at the <code>class-precedence-list</code> of (the class of)
<code>nil</code>.</p>


<h3><a id="section-3.7" name="section-3.7">3.7. Changing a class</a></h3>

<p>This section briefly covers two topics: redefinition of an existing
class, and changing an instance of one class into an instance of
another. In both cases we'll gloss over the details: suffice it to say
that they're hairy but everything's configurable.</p>

<p>To redefine a class, simply evaluate a new <code>defclass</code>
form. This then takes the place of the old definition, the existing
class object is updated, and all instances of the class (and -
recursively - its subclasses) are updated to reflect the new
definition. For example:</p>

<blockquote><pre>
CL-USER 46 &gt; (list Eric (class-of Eric) (slot-exists-p Eric 'has-tail-p))
(#&lt;FIGURINE-AARDVARK 2112B44C&gt;
 #&lt;STANDARD-CLASS FIGURINE-AARDVARK 2150938C&gt;
 NIL)

CL-USER 47 &gt; (defclass animal ()
               ((legs :reader leg-count :initarg :legs)
                (has-tail-p :reader has-tail-p :initform t)
                (comes-from :reader comes-from :initarg :comes-from)))
#&lt;STANDARD-CLASS ANIMAL 2150BA0C&gt;

CL-USER 48 &gt; (list Eric (class-of Eric) (slot-value Eric 'has-tail-p))
(#&lt;FIGURINE-AARDVARK 2112B44C&gt;
 #&lt;STANDARD-CLASS FIGURINE-AARDVARK 2150938C&gt;
 T)

CL-USER 49 &gt;
</pre></blockquote>

<p>You can redefine classes while an application is running, in just
the same way and for the same reasons as you can redefine
functions. The great strength of class redefinition though is during
application development. For example, you can revisit a class and add
a slot or a superclass that you hadn't thought about earlier, without
having to recompile anything other than the new <code>defclass</code>,
and without invalidating any of your objects.</p>

<p>To change the class of an instance, use
<code>change-class</code>:</p>

<blockquote><pre>
CL-USER 49 &gt; (defclass antelope (mammal)
               ((diet :reader munched-by)))
#&lt;STANDARD-CLASS ANTELOPE 2061A14C&gt;

CL-USER 50 &gt; (change-class Eric 'antelope
                           :diet 'greens)
#&lt;ANTELOPE 2112B44C&gt;

CL-USER 51 &gt; (list (slot-exists-p Eric 'potter) (munched-by Eric))
(NIL GREENS)

CL-USER 52 &gt;
</pre></blockquote>

<p>In the above example, a ceramic aardvark has become a graceful Old
World ruminant, automatically losing the slot <code>potter</code> and
explicitly being put on a healthy diet of greens (among other
changes). Leaving aside questions of <a
href="http://ww.telent.net/diary/2002/10/#28.4949">animal cruelty</a>,
this is a powerful feature of CLOS although probably one which you
won't use very often.</p>


<h3><a id="section-3.8" name="section-3.8">3.8. Implementation notes: object wrappers</a></h3>

<p>We'll conclude this part of the tutorial by looking at a possible
implementation for instances, covering:</p>

<ul>
<li>access to local and class slots,</li>
<li>how an instance knows its class but why a class doesn't know its
instances,</li>
<li>preservation of identity when a class is redefined,</li>
<li>lazy updating of slots.</li>
</ul>

<p>This section is extremely implementation-specific, although I have
a sneaky feeling that many implementations will have followed a
similar route. The examples are for illustrative purposes only.</p>

<p>A <cite>wrapper</cite> is an internal structure. Every class -
including structure-classes and built-in-classes - has a wrapper. The
class points to the wrapper and the wrapper points back to the
class. Every call to <code>make-instance</code> allocates two new
structures: a vector of instance slots and the instance itself. The
internal structure of the instance is small: it has two slots,
pointing to the wrapper and to the slots vector.</p>

<div align="center">
<img src="images/fig-4.gif"
     alt="Instance, class and wrapper."
     height="194" width="238" />
<p><a id="figure-4" name="figure-4">
Figure 4. Instance, class and wrapper. The arrows denote the
relationship <cite>points to</cite>.</a></p>
</div>

<p>We can define <code>class-of</code> like this.</p>

<blockquote><pre>
(defun class-of (object)
  (if (built-in-object-p object)
      (built-in-class-of object)
    ;; structures wrappers are similar enough to CLOS instances
    (wrapper-class (instance-wrapper object))))
</pre></blockquote>

<p>The wrapper has the following slots (<strong>note</strong> the
absence of pointers from the wrapper to the instance):</p>

<ul>

<li><p><code>class</code> - points to the instance's class.</p></li>

<li><p><code>cache-number</code> - a fixnum unique to the class
definition; every time a class is defined (including structure and
built-in classes, for reasons which will be made clear at the end of
<a href="#section-4">section 4</a>) some global variable is
incremented and its value is used for the new wrapper.</p></li>

<li><p><code>instance-slot-names</code> - a sequence of the instance's
local slot names. This serves to describe the instance's <cite>slot
layout</cite>.</p></li>

<li><p><code>shared-slots</code> - an association list of shared slot
names and the corresponding values.</p></li>

</ul>

<p>(<strong>Implementation note:</strong> the function
<code>wrapper-of</code> below is not part of Common Lisp. In Allegro
it's in the <code>EXCL</code> package.)</p>

<blockquote><pre>
CL-USER 52 &gt; (clos::wrapper-of Eric)
#&lt;record 1513 (LEGS HAS-TAIL-P COMES-FROM DIET) NIL
 #&lt;STANDARD-CLASS ANTELOPE 2115243C&gt;&gt;

CL-USER 53 &gt;
</pre></blockquote>

<p>An implementation of <code>slot-value</code> might take the
following lines, if it weren't for issues of inefficiency and - in
particular - several failures to follow the CLOS API which we won't go
into here.</p>

<blockquote>
<pre>
(defun slot-value (instance slot-name)
  (validate-instance instance)                   ; See below
  (let* ((wrapper (instance-wrapper instance))
         (local-slot-names (wrapper-local-slot-names wrapper))
         (local-position (position slot-name local-slot-names))
         (value (if local-position
                    ;; It's a local slot.
                    (let ((local-slots (instance-slots instance)))
                      (svref local-slots local-position))
                  (let* ((shared-slots (wrapper-shared-slots wrapper))
                         (shared-slot (assoc slot-name shared-slots)))
                    (if shared-slot
                        ;; It's a class slot.
                        (cdr shared-slot)
		      ;; It's not a slot of this instance.
                      (slot-missing-error instance slot-name))))))
    (if (eq value (the-unbound-slot-value))
        ;; The slot-value has not yet been set. Always an error in CLOS.
        (slot-unbound-error instance slot-name)
      value)))
</pre>
</blockquote>

<p>If a class is redefined it gets a new wrapper with a new
<code>cache-number</code>, and reflecting the new slot layout.  The
<code>cache-number</code> of the old wrapper is zeroed (this marks the
wrapper as <cite>invalidated</cite>). Nothing else is done at this
 stage. CLOS doesn't require instances to be updated until they're
"touched" by the application. A class could therefore be updated
several times without any work having to be done on its instances.</p>

<div align="center">
<img src="images/fig-5.gif"
     alt="Invalid instance, class, new and old wrappers."
     height="197" width="472" />
<p><a id="figure-5" name="figure-5"> Figure 5. "Invalid" instance,
class, new and old wrappers. The greyed-out strutures have been
updated.</a></p>
</div>

<p>Every time the application accesses an instance - for example in
the definition of <code>slot-value</code> above - the CLOS system
needs to know whether that instance has been invalidated, and this
check must be cheap because it's going to happen often. In practice,
<code>validate-instance</code> and everything it calls, except the
revalidation function, would be implemented as macros or inlined
functions to keep the overheads down.</p>

<blockquote><pre>
(defun validate-instance (instance)
  (let ((wrapper (instance-wrapper instance)))
    (when (zerop (wrapper-cache-number wrapper))
      ;; Instance needs revalidation
      (revalidate-instance instance))))
</pre></blockquote>

<p>Revalidation is a laborious process, but the general plan is clear
enough: you follow the chain of pointers through to the new
slot-layout, compare it with the old layout, and build a new
slots vector using the new description and as many of the old
values as are still valid. The instance is left pointing to its fresh
slot vector and the new class wrapper.</p>

<p><strong>Final notes:</strong></p>

<ul>

<li><p><code>change-class</code> follows a route similar to the
revalidation described above, setting the new class wrapper and a
fresh slot vector into an existing instance;</p></li>

<li><p><code>class-of</code> doesn't require validation: the old class
was modified rather than replaced and so the old wrapper points to the
(updated) class;</p></li>

<li><p>indirection through wrappers (see <a href="#figure-4">figure
4</a> above) permits dynamic lookup of slot names, <code>EQ</code>ness
through dynamic redefinition, and lazy modification, all at a low
overhead.</p></li>

</ul>


<h2><a id="section-4" name="section-4">4. Methods</a></h2>


<h3><a id="section-4.1" name="section-4.1">4.1. Review - the non-OO approach</a></h3>

<p>The step up from functions to methods parallels the move from
structures to instances.</p>

<p>Suppose we want to implement our own - simplified - version of
<code>describe</code>:</p>

<blockquote><pre>
CL-USER 53 &gt; (defun my-describe (thing)
               (typecase thing
                 (cons   (describe-cons thing))
                 (symbol (describe-symbol thing))
                 (array  (describe-array thing))
                 (number (describe-number thing))
                 ;; [ etc etc etc ]
                 (t      (describe-whatever thing))))
MY-DESCRIBE

CL-USER 54 &gt; (defun describe-symbol (symbol)
               (let ((package (symbol-package symbol))
                     (boundp (boundp symbol)))
                 (format t
                         "~s is a symbol. ~
      It ~:[~*does not have a home~;is in the ~s~] package. ~
      Its value is ~:[unbound~;~s~]."
                         symbol
                         package (when package (package-name package))
                         boundp (when boundp (symbol-value symbol)))))
DESCRIBE-SYMBOL

CL-USER 55 &gt; (my-describe :foo)
:FOO is a symbol. It is in the "KEYWORD" package. Its value is :FOO.
NIL

CL-USER 56 &gt; (my-describe '#:foo)
#:FOO is a symbol. It does not have a home package. Its value is unbound.
NIL

CL-USER 57 &gt;
</pre></blockquote>

<p>There are a number of problems with this:</p>

<ul>

<li><p>There's no obligation on <code>typecase</code> to be
efficient. Of course in the case of <code>my-describe</code> this
doesn't matter, because the code only runs once per user interaction
and so nobody will ever notice if it isn't as fast as it might have
been. But discrimination according to the type of some program value
is a common operation in lisp and there are many occasions
(e.g. implementing a GUI) where the number of possibilities may be
non-trivial and the overheads in working down a case list are
unacceptable.</p></li>

<li><p>We have to take care ordering the statements (the case for
<code>null</code> would have to preceed <code>symbol</code>.)</p></li>

<li><p>Suppose we wanted to discriminate according to the types of
more than one value?</p>

<blockquote><pre>
(typecase (cons thing stream)
  ((cons array non-scrollable-io)
   (describe-array-non-scrollable array stream))
  ((cons array scrollable-io)
   (describe-array-scrollable array stream))
  ((cons array output-stream)
   (describe-array-general-stream array stream))
  ...)
</pre></blockquote></li>

<li><p>As we keep on thinking up cases, the definition of
<code>my-describe</code> gets longer and longer, as we keep revisiting
it to add more clauses.</p></li>

<li><p>The names of subsidiary functions also risk getting longer and
longer. (Suppose we discriminate on three values, or four...) The code
rapidly gets less readable.</p></li>

</ul>


<h3><a id="section-4.2" name="section-4.2">4.2. Introducing the macro <code>defmethod</code></a></h3>

<p>The defining macro for controlling type-based discrimination in
CLOS is <code>defmethod</code>. An example:</p>

<blockquote><pre>
CL-USER 57 &gt; (fmakunbound 'my-describe)
MY-DESCRIBE

CL-USER 58 &gt; (defmethod my-describe (thing)
               (format t
                       "~s could be anything, for all I care."
                       thing))
#&lt;STANDARD-METHOD MY-DESCRIBE NIL (T) 205EA9E4&gt;

CL-USER 59 &gt; (defmethod my-describe ((animal animal))
               (format t
                       "~s is an animal. It has ~d leg~:p ~
                        and comes from ~a."
                       animal
                       (leg-count animal)
                       (comes-from animal)))
#&lt;STANDARD-METHOD MY-DESCRIBE NIL (ANIMAL) 205F476C&gt;

CL-USER 60 &gt; (my-describe Eric)
#&lt;ANTELOPE 2112B44C&gt; is an animal. It has 4 legs and comes from Brittany.
NIL

CL-USER 61 &gt; (my-describe (make-instance 'figurine))
#&lt;FIGURINE 205FFD14&gt; could be anything, for all I care.
NIL

CL-USER 62 &gt;
</pre></blockquote>

<p>The <code>defmethod</code> form looks like - and is similar to - a
<code>defun</code>. It associates a body of code with the function
name <code>my-describe</code> but - unlike an <cite>ordinary
function</cite> - that body may only be executed if the types of the
arguments match the pattern declared by the lambda list.</p>

<p><strong>Note</strong> that the syntax for invoking a method is
precisely the same as the syntax for invoking an ordinary
function. You cannot tell from the calling code (e.g. lines 60 and 61
above) whether the call is to an ordinary function or a CLOS
method. You can call methods from ordinary functions, and ordinary
functions from methods, and generally mix them together.</p>

<p>Moving onto the <code>defmethod</code> form itself, the way that
pattern matching works is that the required parameters in the method's
lambda list may take one of the following two forms:
<cite>variable</cite> or <cite>(variable specializer)</cite>. In the
first case, <cite>variable</cite> is bound to the corresponding
argument value as usual. However in the latter case,
<cite>variable</cite> is bound to the corresponding argument only if
that argument is of class <cite>specializer</cite> (or a subclass). If
any argument fails to match its specializer then the method is not
<cite>applicable</cite> and it cannot be executed with those
arguments.</p>

<p>You can define any number of methods with the same function name
but with different specializers. The system chooses the most
<cite>specific</cite> applicable method - that is, the applicable
method whose specializers are nearest to the head of the
<code>class-precedence-list</code> corresponding to each argument -
and executes its body.</p>

<p>In the above example, we defined two methods on
<code>my-describe</code>. The first one does not specialize on its
argument and so that method is always applicable. The second method
specializes its argument on the class <code>animal</code>, and so is
applicable only if this argument is an <code>animal</code>.</p>

<p>In line 60 we describe an <code>animal</code>. Both methods are
applicable. How does the system choose which one to invoke?</p>

<blockquote><pre>
CL-USER 62 &gt; (mapcar 'class-name
                     (class-precedence-list (class-of Eric)))
(ANTELOPE MAMMAL ANIMAL STANDARD-OBJECT T)

CL-USER 63 &gt;
</pre></blockquote>

<p>The specialized method is more <cite>specific</cite> because its
specializer appears earlier in the precedence list than that of the
<cite>unqualified</cite> (or <cite>default</cite>) method:
<code>animal</code> precedes <code>t</code>. Another way of expressing
this is that the specialized method <cite>overrides</cite> the
unqualified one.</p>

<p>In line 61 we describe a <code>figurine</code>. This time only one
of the two methods is applicable, because the class
<code>figurine</code> is not a subclass of <code>animal</code>.</p>


<p>This matching process has two consequences:</p>

<ul>

<li><p>dispatch by discrimination according to the type of a program
value, which is just what we were looking for; and</p></li>

<li><p>as an interesting side effect, an implied guarantee about the
class of a specialized value inside the method body, which has
implications for optimization (for example, of calls to
<code>slot-value</code>).</p></li>

</ul>

<p><strong>Notes:</strong></p>

<ul>

<li><p>It's an error to define a method with the same function name as
an ordinary function, hence the call to <code>fmakunbound</code>
above.</p></li>

<li><p>Methods can be redefined (exactly as for ordinary
functions).</p></li>

<li><p>The order in which methods are defined is irrelevant, although
any classes on which they specialize must already exist.</p></li>

<li><p>An unspecialized argument is more or less equivalent to being
specialized on the class <code>t</code>. The only difference is that
all specialized arguments are implicitly taken to be "referred to" (in
the sense of <code>declare ignore</code>.)</p></li>

<li><p>Each <code>defmethod</code> form generates (and returns) a CLOS
instance, of class <code>standard-method</code>.</p></li>

</ul>

<p><strong>Exercise:</strong> All CLOS objects are printed by a method
on <code>print-object</code>, whose arguments are <code>(object
stream)</code>. Define methods for printing <code>aardvark</code>s and
<code>antelope</code>s more interestingly than by the default
method. How might the default method (for printing a
<code>standard-object</code>) be defined?</p>

<p><strong>Exercise</strong> (in which I am indebted to Steve Haflich
for his clarifications): Consider the following code and form
unassailable opinions as to the circumstances in which a compiler
might be entitled to eliminate either of the tests in the method
body.</p>

<blockquote><pre>
(defclass frob (standard-object) ())

(defmethod foo ((baz frob))
   (loop initially (mangle)
      while baz do
         (etypecase baz
            (frob (setf baz (bar baz)))))))
</pre></blockquote>



<h3><a id="section-4.3" name="section-4.3">4.3. Generic functions and next methods</a></h3>

<p>A <cite>generic function</cite> is a lisp function which is
associated with a set of methods and dispatches them when it's
invoked. All the methods with the same function name belong to the
same generic function.</p>

<p>The first time we defined a method on <code>my-describe</code>, we
implicitly created a generic function with that name. The generic
function initially had a single method, until we added a second method
with the same name.</p>

<p>(<strong>Implementation note:</strong> the functions
<code>generic-function-methods</code> and
<code>method-generic-function</code> below are not part of Common
Lisp. In LispWorks they're available via your default
<code>package-use-list</code>, in Allegro they're exported from
<code>ACLMOP</code>.)</p>

<blockquote><pre>
CL-USER 63 &gt; #'my-describe
#&lt;STANDARD-GENERIC-FUNCTION MY-DESCRIBE 21111C2A&gt;

CL-USER 64 &gt; (generic-function-methods #'my-describe)
(#&lt;STANDARD-METHOD MY-DESCRIBE NIL (T) 2110B544&gt;
 #&lt;STANDARD-METHOD MY-DESCRIBE NIL (ANIMAL) 21111BF4&gt;)

CL-USER 65 &gt; (method-generic-function (car *))
#&lt;STANDARD-GENERIC-FUNCTION MY-DESCRIBE 21111C2A&gt;

CL-USER 66 &gt;
</pre></blockquote>

<p><strong>Some notes:</strong></p>

<ul>

<li><p>In <a href="#section-4.2">section 4.2</a> above we mentioned
"invoking a method". To be accurate, the application cannot directly
invoke a method. If the application calls a function which happens to
be a generic function, then this will dispatch to (i.e. invoke) the
most applicable method.</p></li>

<li><p>Methods can have optional, keyword and <code>&amp;rest</code>
arguments. These must be compatible (<cite>congruent
lambda lists</cite>) between every method of each generic
function. For example, if there existed an optional
<code>stream</code> argument in one of the two methods on
<code>my-describe</code> then this argument would have to be present
and optional in the other.</p></li>

<li><p>All slot accessors / readers defined by <code>defclass</code>
are methods. They can override or be overridden by other methods on
the same generic function.</p></li>

</ul>

<p>When a generic function is invoked, the dispatch mechanism proceeds
as follows:</p>

<ol>

<li><p>compute the list of applicable methods;</p></li>

<li><p>if no method is applicable then signal an error;</p></li>

<li><p>sort the applicable methods in order of specificity;</p></li>

<li><p>invoke the most specific method.</p></li>

</ol>

<p>During the execution of a method, the remaining applicable methods
are still accessible, via the <cite>local function</cite>
<code>call-next-method</code>. This function has lexical scope within
the body of a method but indefinite extent. It invokes the next most
specific method, and returns whatever value that method returned. It
can be called with either:</p>

<ul>

<li><p>no arguments, in which case the <cite>next method</cite> will
receive exactly the same arguments as this method did; or</p></li>

<li><p>explicit arguments, in which case it is required that the
sorted set of methods applicable to the new arguments must be the same
as that computed when the generic function was first called.</p></li>

</ul>

<p>Calling <code>call-next-method</code> when there is no next method
signals an error. You can find out whether a next method exists by
calling the local function <code>next-method-p</code> (which also has
has lexical scope and indefinite extent).</p>

<blockquote><pre>
CL-USER 66 &gt; (defmethod my-describe ((antelope antelope))
               (if (string= (slot-value antelope 'comes-from)
                            "Brittany")
                   (format t "Eric? Is that you?")
                 (call-next-method)))
#&lt;STANDARD-METHOD MY-DESCRIBE NIL (ANTELOPE) 20603594&gt;

CL-USER 67 &gt; (my-describe
              (make-instance 'antelope :comes-from 'nowhere :legs 4))
#&lt;ANTELOPE 205ECB64&gt; is an animal. It has 4 legs and comes from NOWHERE.
NIL

CL-USER 68 &gt; (my-describe Eric)
Eric? Is that you?
NIL

CL-USER 69 &gt;
</pre></blockquote>

<p><strong>Note</strong> finally that the body of every method
establishes a block with the same name as the method's generic
function. If you <code>return-from</code> that name you are exiting
the current method, not the call to the enclosing generic
function.</p>

<p><strong>Exercise:</strong> Use your lisp implementation, to take a
look at the <code>class-precedence-list</code> of generic
functions.</p>

<p><strong>Exercise:</strong> When you evaluate <code>(comes-from
Eric)</code>, from which class is the reader inherited? Override this
method, so that Antelopes always come from Africa. (This isn't true,
but it's an improvement.)</p>

<p><strong>Exercise:</strong> Experiment with the indefinite extent of
<code>call-next-method</code>.</p>


<h3><a id="section-4.4" name="section-4.4">4.4. In OO languages the functionality lives in the object</a></h3>

<p>This preposterous claim is the product of a diseased
imagination. However many OO systems feel obliged to try and enforce
it. Try to avoid having to program in one of these.</p>

<p>As far as CLOS is concerned, the truth is that - with the exception
of slot accessors - all of your application's functionality lives in
function and method definitions, not in classes.</p>

<p>It's sometimes appropriate to place methods applicable to some
class into the same file as that class. It's sometimes appropriate to
place all the methods of a generic function into a single file. There
are no language constraints on this.</p>

<p>Hand in hand with the title of this section comes the notion of
<cite>message passing</cite>. This derives from OO systems which only
allow you to specialize on the first argument. This argument is then
given linguistic prominence, and the function call is given a new
syntax to reflect that:</p>

<blockquote><pre>Eric&lt;-(my-describe)</pre></blockquote>

<p>You'd read that as <cite>send the message</cite>
<code>my-describe</code> to <code>Eric</code> (in this case with no
<cite>additional</cite> arguments). C++ is an obvious culprit:
<code>Eric::my_describe();</code></p>

<p>CLOS supports <cite>multi-methods</cite> - methods that can
specialize on more than one argument. Although you might not use that
much, it's liberating. Not only does it free you from the truly horrid
code you can end up with as programmers struggle to get around the
restrictions of the message-passing paradigm, but it implies that
methods don't have to live inside classes. (If a method specializes on
two classes, which one would it live in?) A consequence is that you
can redefine one of your methods without having to recompile the class
and with it 500 other methods. That's nice.</p>

<p><strong>A stylistic note:</strong> there's an occasional tendency,
maybe borrowed from languages which don't support multi-methods, to
call "the" specialized argument <code>self</code>:</p>

<blockquote><pre>(defmethod wibble ((self aardvark) ...) ...)</pre></blockquote>

<p>If the methods of a generic function only specialize on the same
argument, this is no better or worse than calling arguments after the
class they specialize:</p>

<blockquote><pre>(defmethod wibble ((aardvark aardvark) ...) ...)</pre></blockquote>

<p>Do whatever makes your code clearer.</p>

<p><strong>Exercise:</strong> Lisp's <code>describe</code> is
implemented by the generic function
<code>describe-object</code>. Implementations are expected to define
sufficient methods (and users are encouraged to add more if they
like), specializing on the two arguments <code>object</code> and
<code>stream</code>. Discuss whether the implementors should group all
the methods on <code>describe-object</code> into one file, or spread
them around (so that - for instance a method specializing on
<code>aardvark</code>s should be in the file "aardvark.lisp" along
with the class definition and other methods). What are the issues?</p>

<p><strong>Exercise:</strong> Find some excuse to specialize a method
on its second argument, or on more than one argument.</p>



<h3><a id="section-4.5" name="section-4.5">4.5. Other specializers (you still don't need CLOS objects to use CLOS)</a></h3>

<p>The examples of methods shown so far all specialize on
<code>standard-class</code>es. That isn't necessary. You can specialize on any CLOS
class: for example the system classes listed near the top of
<a href="#section-3.4">section 3.4</a>, or any structure class.</p>

<blockquote><pre>
CL-USER 69 &gt; (defmethod my-describe ((self structure-object))
               (format t "~s is a structure object."
                       self))
#&lt;STANDARD-METHOD MY-DESCRIBE NIL (STRUCTURE-OBJECT) 205F5744&gt;

CL-USER 70 &gt; (my-describe (make-foo))
#S(FOO) is a structure object.
NIL

CL-USER 71 &gt; (defmethod my-describe ((self foo))
               (format t "bar"))
#&lt;STANDARD-METHOD MY-DESCRIBE NIL (FOO) 205F3ADC&gt;

CL-USER 72 &gt; (my-describe (make-foo))
bar
NIL

CL-USER 73 &gt;
</pre></blockquote>

<p>You can use methods in your code without ever defining a CLOS
class, just as you can use CLOS classes without a single
<code>defmethod</code>. These two parts of CLOS are independent -
think of them as two object systems for the price of one.</p>

<p>Another form of specializer, which will occasionally be useful, is
known as an <cite>eql specializer</cite>. In this case, the
specializing class name is replaced by a list whose first element is
the symbol <code>eql</code> and whose second value is any lisp
form. That form is evaluated at the same time as the
<code>defmethod</code>. In order for the method to be applicable, the
corresponding argument must be <code>eql</code> to the result of that
evaluation. An <cite>eql method</cite> is more specific than one
specializing on classes.</p>

<blockquote><pre>
CL-USER 73 &gt; (defmethod my-describe ((self (eql pi)))
               (format t "approximately 22/7"))
#&lt;STANDARD-METHOD MY-DESCRIBE NIL ((EQL 3.141592653589793)) 2060E57C&gt;

CL-USER 74 &gt; (defmethod my-describe ((self float))
                (format t "some float"))
#&lt;STANDARD-METHOD MY-DESCRIBE NIL (FLOAT) 2061EEF4&gt;

CL-USER 75 &gt; (my-describe pi)
approximately 22/7
NIL

CL-USER 76 &gt;
</pre></blockquote>

<p></p>


<p><strong>Exercise:</strong> Write a method on
<code>my-describe</code> for lists. </p>

<p><strong>Exercise:</strong> Write a method on
<code>print-object</code> for <code>Eric</code> the antelope. Change
the <code>class-of Eric</code>. Do you expect your method to still be
applicable?</p>



<h3><a id="section-4.6" name="section-4.6">4.6. Qualifiers and method combination</a></h3>

<p>Let's start with a word of warning. Reckless use of method
combination can - like an unfettered hand with multiple inheritance -
<a
href="http://www.cogsci.princeton.edu/cgi-bin/webwn1.7.1?stage=1&amp;word=spaghetti">tangle</a>
your code beyond recognition.</p>

<p>The full syntax for <code>defmethod</code> is:</p>

<blockquote><pre>
<strong>defmethod</strong> <cite>function-name {method-qualifier}* specialized-lambda-list
          [[declaration* | documentation]] form*</cite>
</pre></blockquote>

<p>We're only going to look here at the default, or <cite>standard
method combination</cite>. (Other method combinations are available,
and you can even define your own but I'm not sure I've ever met anyone
who did.) With standard method combination, no more than one
<cite>method qualifier</cite> is permitted per method, and if present
is must be one of the following keywords: <code>:before</code>,
<code>:after</code> and <code>:around</code>. The methods without a
qualifier are known as <cite>primary</cite> methods. The full dispatch
mechanism for generic functions is as follows; <strong>note</strong>
that <code>:before</code> and <code>:after</code> methods are only run
for their side effects.</p>

<ol>

<li><p>compute the applicable methods, and partition them into
separate lists according to their qualifier;</p></li>

<li><p>if there is no applicable primary method then signal an
error;</p></li>

<li><p>sort each of the lists into order of specificity;</p></li>

<li><p>execute the most specific <code>:around</code> method and
return whatever that returns;</p></li>

<li><p>if an <code>:around</code> method invokes
<code>call-next-method</code>, execute the next most specific
<code>:around</code> method;</p></li>

<li><p>if there were no <code>:around</code> methods in the first
place, or if an <code>:around</code> method invokes
<code>call-next-method</code> but there are no further
<code>:around</code> methods to call, then proceed as follows:</p>

    <ol type="a">

    <li><p>run all the <code>:before</code> methods, in order,
    ignoring any return values and not permitting calls to
    <code>call-next-method</code> or
    <code>next-method-p</code>;</p></li>

    <li><p>execute the most specific primary method and return
    whatever that returns;</p></li>

    <li><p>if a primary method invokes <code>call-next-method</code>,
    execute the next most specific primary method;</p></li>

    <li><p>if a primary method invokes <code>call-next-method</code>
    but there are no further primary methods to call then signal an
    error;</p></li>

    <li><p>after the primary method(s) have completed, run all the
    <code>:after</code> methods, in <strong><u>reverse</u></strong>
    order, ignoring any return values and not permitting calls to
    <code>call-next-method</code> or
    <code>next-method-p</code>.</p></li>

    </ol>

</li>

</ol>

<p>If you think all this looks insanely complicated, you're probably
right. Think of it as an onion, with all the <code>:around</code>
methods in the outermost layer, <code>:before</code> and
<code>:after</code> methods in the middle layer, and primary methods
on the inside. Be grateful there are only three layers. To make the
model work, it helps conceptually to pair <code>:before</code> and
<code>:after</code> methods like this:</p>

<blockquote><pre>
(defmethod spong :before-and-after (&amp;rest args)
  (let ((before (find-method #'spong '(:before) args))
        (after  (find-method #'spong '(:after) args)))
    (when before (invoke-method before args))
    (multiple-value-prog1
        (call-next-before-and-after-method)
      (when after (invoke-method after args)))))
</pre></blockquote>

<p><strong>Note</strong> how this gives us a reversed order for
<code>:after</code> methods. This happens quite naturally, which might
explain why the reversal was specified in the first place.</p>

<p>In real life (you hope) the situation won't get that complicated. A
simple example: <code>my-describe</code> suppressing return values.</p>

<blockquote><pre>
CL-USER 76 &gt; (defmethod my-describe :around (self)
               (call-next-method)
               (values))
#&lt;STANDARD-METHOD MY-DESCRIBE (:AROUND) (T) 20605A34&gt;

CL-USER 77 &gt; (my-describe Eric)
Eric? Is that you?

CL-USER 78 &gt;
</pre></blockquote>

<p>Another example: The CLOS implementation of
<code>make-instance</code> is in two stages: allocate the new object,
and then pass it along with all the <code>make-instance</code> keyword
arguments, to the generic function
<code>initialize-instance</code>. Implementors and application writers
define <code>:after</code> methods on
<code>initialize-instance</code>, to initialize the slots of the
instance. The system-supplied primary method does this with regard to
(a) <code>:initform</code> and <code>:initarg</code> values supplied
with the class was defined and (b) the keywords passed through from
<code>make-instance</code>. Other methods can extend this behaviour as
they see fit. For example, they might accept an additional keyword
which invokes a database access to fill certain slots. The lambda list
for <code>initialize-instance</code> is:</p>

<blockquote><pre><strong>initialize-instance</strong> <cite>instance</cite> &amp;rest <cite>initargs</cite> &amp;key &amp;allow-other-keys</pre></blockquote>

<p><strong>Exercise:</strong> Add an <code>:after</code> method to
<code>initialize-instance</code> to make all aardvarks come from
Cambridge, England. Add another method (qualified how?) to prohibit
the following interaction:</p>

<blockquote><pre>(make-instance 'cannibal :diet (make-instance 'cannibal))</pre></blockquote>

<p><strong>Exercise:</strong> You might choose to regard
<code>initialize-instance</code> as a souped-up analogue of the
<cite>constructors</cite> offered by other OO systems. But CLOS
doesn't offer a <cite>destructor.</cite> Should this matter?</p>


<h3><a id="section-4.7" name="section-4.7">4.7. Implementation notes: generic function dispatch</a></h3>

<p>Computing, sorting and executing a list of applicable methods are
time-consuming operations. An implementation will typically want to
cache its results and reuse them as often - but as cheaply - as
possible. An implementor once told me that his aim was to make "best
case" generic function dispatch no more than three times slower than
calling an ordinary function. </p>

<p>The method cache cannot be calculated in advance, because (a) we
typically don't know what arguments might be passed to the generic
function in future and (b) there are so many classes in the system
that the cache might be enormous, particularly if the generic function
specializes on more than one argument. Therefore the cache has to be
augmented <cite>on the fly</cite> as the application runs.</p>

<p>The following strategies might be useful:</p>

<ul>

<li><p>A generic function is both a function and a CLOS
instance. Implement the former by closing system template code over
the latter.</p></li>

<li><p>Implement method execution (steps 4 though 6 in the "full
dispatch mechanism" described in <a href="#section-4.6">section
4.6</a> above) by closing pre-compiled templates over sorted lists of
applicable methods, thus generating <cite>combined methods</cite>. A
combined method is a funcallable object which takes the same arguments
as the generic function, and which handles the all aspects of method
combination when the arguments are of given classes.</p></li>

<li><p>Only <cite>invoke the compiler</cite> - i.e. only generate
fresh dispatch code - if no pre-compiled template exists. For example,
the implementation might be prepared for generic functions which
specialize on up to ten arguments, and then some benevolent user
writes a generic function which specializes on all eleven.</p></li>

<li><p>Maintain a "slow-lookup" cache within each generic function,
associating classes of arguments against combined methods. This cache
is augmented every time the generic function is called with arguments
whose classes have not previously been seen by the generic
function.</p></li>

<li><p>Also maintain optimized "fast-lookup" caches, associating
classes of the arguments used in the last few calls to this generic
function against combined methods.</p></li>

<li><p>If a new method is added, throw away the caches rather than
attempt to modify them. Method definition is much rarer than method
invocation.</p></li>

<li><p>Consider special cases. For example, a gratifyingly high
proportion of generic functions in a typical application will only
have one method, and these can be optimized accordingly.</p></li>

</ul>

<p>The assumption behind the fast-lookup cache is that any given call
to a generic function is likely to have arguments of the same class as
one of the last few calls. This cache is responsible for the "no more
than three times slower" property mentioned above, and so has to be
very fast indeed. A possible implementation is as a flat vector, using
the following lookup scheme. <strong>Note</strong> that this scheme
does not allocate.</p>

<ol>

<li><p>Obtain the wrapper of the first specialized argument (recall:
wrappers are associated with all lisp objects, not just CLOS
instances). For CLOS or structure objects this is very fast, for
built-in objects it's worth optimizing.</p></li>

<li><p>Validate the wrapper (so the cache-number will be up to
date).</p></li>

<li><p>Fetch the wrapper's <code>cache-number</code>, divide it by the
length of the cache vector, and take the remainder.</p></li>

<li><p>Use this value as an index into the cache. If the value in the
cache at that location is the wrapper in question, we look at the next
location and compare that with the wrapper of the next specialized
argument, and so on until we've matched all the arguments against
wrappers in the cache. If we get that far, we look one location
further on still and there we hope to find the combined
method.</p></li>

<li><p>If any of the above failed, we have a cache miss. Go to the
list of classes and combined methods in the main cache and use
<code>assoc</code> to locate the combined method. (If this too fails,
calculate the combined method - at this point we have to bite the
bullet and allocate - and add it to the slow cache.) Write the
argument wrappers and combined method into the fast cache.</p></li>

</ol>

<p><strong>To discuss over dinner:</strong> How large do you think the
fast-lookup cache should be?</p>

<p><strong>To discuss over dinner:</strong> How might an
implementation optimize the process of obtaining the wrappers of
built-in objects (such as numbers and strings)? Answers involving
<code>assoc</code> on the type, or <code>typecase</code>, are
incorrect.</p>

<p><strong>To discuss over dinner:</strong> How might the above be
modified to take account of <code>eql</code> methods?</p>


<h2><a id="section-A" name="section-A">A. References</a></h2>


<table>


<tr valign="top">

  <td>[Graham 1995]</td>

  <td>
    "ANSI Common Lisp"; <a href="mailto:pg@paulgraham.com">Paul
    Graham</a>; Prentice Hall; 1995; ISBN 0133708756. See <a
    href="http://www.paulgraham.com/acl.html">http://www.paulgraham.com/acl.html</a>
  </td>

</tr>

<tr valign="top">

  <td>[Keene 1989]</td>

  <td>
    "Object-Oriented Programming in Common Lisp";
    Sonya E. Keene; Addison-Wesley; 1989; ISBN 0201175894.
  </td>

</tr>

<tr valign="top">

  <td>[Kiczales et al 1991]</td>

  <td>
    "The Art of the Metaobject Protocol"; Gregor Kiczales, Jim des
    Rivi&egrave;res, Daniel G. Bobrow; MIT Press; 1991; ISBN
    0262610744.
  </td>

</tr>

<tr valign="top">

  <td>[Pitman 1996]</td>

  <td>
    "The Common Lisp Hyperspec"; <a
    href="mailto:pitman@nhplace.com">Kent M. Pitman</a> (editor);
    1996. Available online at <a
    href="http://www.lispworks.com/reference/HyperSpec/Front/index.htm">http://www.lispworks.com/reference/HyperSpec/Front/index.htm</a>
  </td>

</tr>

<tr valign="top">

  <td>[Steele 1990]</td>

  <td>
    "Common Lisp the Language, 2nd edition";
    Guy L. Steele Jr.; Digital Press; 1990; ISBN 1555580416.
    Available online at <a
    href="http://www-2.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html">http://www-2.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html</a>
  </td>

</tr>


</table>



<h2><a id="section-B" name="section-B">B. Document History</a></h2>

<table>

<tr valign="top">

  <td>2003-07-15</td>

  <td><a href="mailto:ndl@ravenbrook.com">NDL</a></td>

  <td>Placeholder document created.</td>

</tr>

<tr valign="top">

  <td>2003-08-13</td>

  <td><a href="mailto:ndl@ravenbrook.com">NDL</a></td>

  <td>Drafting started.</td>

</tr>

<tr valign="top">

  <td>2003-08-26</td>

  <td><a href="mailto:ndl@ravenbrook.com">NDL</a></td>

  <td>First draft complete.</td>

</tr>

<tr valign="top">

  <td>2003-09-01</td>

  <td><a href="mailto:ndl@ravenbrook.com">NDL</a></td>

  <td>Corrections following review.</td>

</tr>

</table>

<h2><a id="section-C" name="section-C">C. Partial class hierarchy</a></h2>

<div align="center">
<img
src="images/fig-6.gif" alt="Partial class hierarchy."  height="370"
width="434" />
<p><a id="figure-6" name="figure-6"> Figure 6. Partial class
hierarchy. The arrows denote the <cite>superclass</cite>
relationship. All classes are instances of
<code>standard-class</code>, apart from <code>t</code> and
<code>function</code> which are instances of
<code>built-in-class</code> and <code>generic-function</code> which is
an instance of <code>funcallable-standard-class.</code></a></p>
</div>


<hr />

<p><small>This document is provided "as is", without any express or
implied warranty.  In no event will the author be held liable for any
damages arising from the use of this document.  You may make and
distribute verbatim copies of this document provided that you do not
charge a fee for this document or for its distribution.</small></p>

<div align="center">

<p><code>$Id: index.html,v 1.1 2003/10/21 13:49:26 nicklevine Exp $</code></p>

<p>
<a href="http://www.ravenbrook.com/">Ravenbrook</a> /
<a href="http://www.international-lisp-conference.org/">ILC 2003</a>
</p>

<p>
    <a href="http://validator.w3.org/check/referer">
    <img src="./valid-xhtml10.png"
         alt="Valid XHTML 1.0!" height="31" width="88" /></a>
</p>

</div>

</body>

</html>
