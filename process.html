<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "DTD/xhtml1-transitional.dtd">
<!-- 	$Header: /cvsroot/cl-cookbook/cl-cookbook/process.html,v 1.8 2002/06/26 14:42:03 nicklevine Exp $	 -->
<html> <head>
<title>The Common Lisp Cookbook - Threads</title>
<style type="text/css">
<!---
    pre { margin-left:20px; background-color:#e0e0e0 }
    code { background-color:#e0e0e0 }
 -->
</style>

</head>

<body bgcolor="white">
<h1><a href="index.html">The Common Lisp Cookbook</a> - Threads</h1>


<p>This page is only partially written. Still, half is better than
none...</p>

<h2>Contents</h2>

<ul>
<li><a href="#why_bother">Why bother?</a></li>
<li><a href="#basics">Basics</a></li>
<li><a href="#output">Where's my output?</a></li>
<li><a href="#communicating_1">Communicating with other threads 1: <code>mp:process-wait</code></a></li>
<li><a href="#initializing">Initializing multithreading</a>  <i>(under construction)</i></li>
<li><i>and more</i></li>
</ul>

<p>By <cite>threads</cite>, I mean separate execution strands within a
single Lisp process. For information about communication with other
<cite>processes</cite>, see <a href="os.html">Interfacing with your
OS</a>.</p>

<p>The ANSI Common Lisp standard doesn't mention this topic. So almost
everything that can be said here depends on your OS and your
implementation.</p>

<p>Speaking of implementations, the following discussion currently
refers only to <a href="http://www.xanalys.com/">Xanalys</a> <a
href="http://www.xanalys.com/software_tools/products/">LispWorks</a>.
It has been tested on LispWorks for Windows version 4.2.6 running on
Windows NT (SP 6). Your mileage may vary. I will add "support" for
other implementations and operating systems to this page later, if I
have the time and access to the appropriate materials.</p>

<a name="why_bother"></a>
<h3>Why bother?</h3>

<p>The first question to resolve is: why bother with threads?
Sometimes your answer will simply be that your application is so
straightforward that you need not concern youself with threads at
all. But in many other cases it's difficult to imagine how a
sophisticated application can be written without multi-threading. For
example:</p>

<ul>

<li>you might be writing a server which needs to be able to respond to
more than one user / connection at a time;</li>

<li>you might want to perform some background activity, without
halting the main application while this is going on;</li>

<li>you might want to keep the application running while waiting for
some system resource to become available;</li>

<li>you might need to interface with some other system which requires
multithreading (for example, "windows" under Windows generally run in
their own threads);</li>

<li>you might want to associate different contexts (e.g. different
dynamic bindings) with different parts of the application;</li>

<li>you might even have the simple need to do two things at once.</li>

</ul>

<a name="basics"></a><h3>Basics</h3>

<p>In order to run a function in a separate thread, you need to do two
things.</p>

<ol>

<li>Make sure that multithreading is running. By default,
multithreading is always running in the LispWorks for Windows
environment so in this case there is nothing to do. See
<a href="#initializing">initializing multithreading</a> below to find
out how to get threads running on other platforms.</li>

<li>Now call your function, in its new thread. For example:

<pre>
(defvar *foo* 0)
(defun foo () (incf *foo*))
(mp:process-run-function "Incrementing *foo*" nil 'foo)
*foo*  => 1
</pre>

</li>
</ol>

<p>In the above example, you created a new thread called
<code>"Incrementing *foo*"</code>. The function <code>foo</code> was
invoked (with no arguments) in that thread. When <code>foo</code>
returned, the thread no longer had any work to do and so was
terminated.</p>

<p>Note the following:</p>

<ul>

<li>The first argument to <code>mp:process-run-function</code> is a
string naming the thread. You don't have to make the names unique, but
it's a smart move if you do in actual code, as it's a great way to
tell your threads apart when you're debugging them. When playing
around in the listener, you'll often find no harm in using an empty
string here.</li>

<li>The second argument to <code>mp:process-run-function</code> is a
list of <cite>process initialization keywords</cite>. You'll almost
always leave this empty (so you needn't bother about any details).</li>

<li>The third argument is the function to invoke in the new
thread. This should be a function designator, for example, an <code>fboundp</code>
symbol or a <code>lambda</code> form. </li>

<li>Any remaining arguments to <code>mp:process-run-function</code>
are passed to your function. So calls to
<code>mp:process-run-function</code> look like calls to
<code>funcall</code> with two additional arguments at the
beginning.</li>

<li>A call to <code>mp:process-run-function</code> returns immediately
(the return value is of type <code>mp:process</code>), while the new
thread executes asynchronously.</li>

</ul>

<p>Another simple example:</p>

<pre>
CL-USER 15 &gt; (mp:process-run-function "sleep in the background" nil 'sleep 10)
#&lt;MP:PROCESS Name "sleep in the background" Priority 850000 State "Running"&gt;

CL-USER 16 &gt; (mp:find-process-from-name "sleep in the background")
#&lt;MP:PROCESS Name "sleep in the background" Priority 0 State "Sleeping on mailbox"&gt;

CL-USER 17 &gt; (sleep 10)     ;; At this point the listener sleeps for ten seconds
NIL

CL-USER 18 &gt; (mp:find-process-from-name "sleep in the background")
NIL                         ;; The background process has finished its job and terminated

CL-USER 19 &gt;
</pre>

<p><strong>Warning!</strong> Note the difference between:</p>

<pre>(dotimes (i 20)
  (mp:process-run-function "One closure" ()
                           (lambda () (print i #.*standard-output*))))
</pre>
<p>and</p>
<pre>
(dotimes (i 20)
  (mp:process-run-function "Twenty different bindings" ()
                           (lambda (j) (print j #.*standard-output*))
                           i))
</pre>

<p>In the first case, all twenty threads share the same closure
variable <code>i</code>. The threads execute
<cite>asynchronously</cite> - in other words there's no way to tell
exactly when or in what order they'll execute. In this case (try it!)
the observed behaviour is that LispWorks initialises all 20 threads
before any of them have a chance to start running. By far the easiest
way of dealing with this is to ensure that variables which need to be
private to each thread are bound on a per-thread basis.</p>

<p><strong>Exercise:</strong> get two or three new threads running
simultaneously, and convince yourself they're all there.</p>


<a name="output"></a><h3>Where's my output?</h3>

<p>An obvious way to test whether threads are behaving as you imagine
they ought, is to get them to print messages to the listener. For
example, you might feel justified in trying something like:</p>

<pre>
CL-USER 23 &gt; (mp:process-run-function "test" () (lambda () (print 99)))
#&lt;MP:PROCESS Name "test" Priority 850000 State "Running"&gt;

CL-USER 24 &gt; ;; Where's my output?
</pre>

<p>Where indeed is your output? The answer is that your new thread has
a different <code>*standard-output*</code> to the listener, and that's
where your output has gone to. Here is how you might find out where
precisely that is:</p>

<pre>
CL-USER 25 &gt; (mp:process-run-function
              "" ()
              (lambda ()
                (print *standard-output* #.*standard-output*)))
#&lt;MP:PROCESS Name "" Priority 850000 State "Running"&gt;

#&lt;Synonym stream to *TERMINAL-IO*&gt;
CL-USER 26 &gt;
</pre>

<p><strong>Exercise:</strong> Open the console
(i.e. <code>*terminal-io*</code>) by evaluating <code>(read-char
*terminal-io*)</code>; type a <code>#\Newline</code> into the console
to return from <code>read-char</code>. Now you can prove directly where
a thread's output goes (by sending something there).</p>



<a name="communicating_1"></a><h3>Communicating with other threads 1: <code>mp:process-wait</code></h3>

<p>In all the above examples, a thread is created to run a simple
function and then halt. In a typical application at least some of your
threads will run an <cite>event loop</cite> of some sort. An event
loop is a function which repeatedly waits for an external event to
occur. When an event is noticed, it is dispatched (maybe to another
thread) for processing and the event loop cycles back to its waiting
state. The "other thread" here might already exist (perhaps running an
event loop of its own) or might be created specifically to perform
this task (i.e. handle a single event) and then terminate.</p>

<p>It might be tempting to construct an event loop using
<code>cl:sleep</code>. For example:</p>

<pre>
(defun bogus-event-loop ()
  (loop
   (sleep 1)                        ; THIS IS WRONG
   (when (something-has-happened)
     (act-on-that-thing))))

(mp:process-run-function "Bogus event loop" ()
                         'bogus-event-loop)
</pre>

<p>This is a poor choice, because you're condemned to waiting for the
<code>sleep</code> to return before you can perform the wake-up
test. (Also, it's possible that your implementation cannot sleep one
single thread without sleeping the whole lisp process. In such cases,
any processing required before the predicate
<code>something-has-happened</code> can return true will never happen.)</p>

<p>Consider instead:</p>

<pre>
(defun improved-event-loop ()
  (loop
   (mp:process-wait "Waiting for something to happen"
                    'something-has-happened)
   (act-on-that-thing)))
</pre>

<p>The arguments to <code>mp:process-wait</code> are a string (which
you should use for describing what this thread is waiting for), a
function and optionally arguments to that function. The current thread
will effectively sleep until the function returns true. The function
can watch either internal state...</p>

<pre>
(defun flush-entries-to-file (entries-symbol max-length file)
  (loop
   ;; Wait until we have enough entries to justify going to disk.
   (mp:process-wait (format nil "Waiting for ~a entr~:@p" max-length)
                    (lambda ()
                      (>= (length (symbol-value entries-symbol)) max-length)))
   ;; In this example, don't bother to spawn off a new thread to
   ;; perform the task.
   (let ((entries (shiftf (symbol-value entries-symbol) nil)))
     (with-open-file (ostream file
                              :direction :output
                              :if-exists :append
			      :if-does-not-exist :create)
       (format ostream "~%Flushing entries:")
       (dolist (entry (reverse entries))
         (print entry ostream))))))

;; Test bed to drive the event loop
(defvar *test-entries* nil)
(defvar *test-file* "c:/temp/test-flush-entries.txt")
(defun test-flush-entries-to-file ()
  (let ((tester
         (mp:process-run-function "Test writing entries to file" ()
                                  'flush-entries-to-file
                                  '*test-entries*
                                  10
                                  *test-file*)))
    (dotimes (i 100)
      (push i *test-entries*)
      ;; Without the delay introduced by sleep, all 100 entries are
      ;; generated before the flusher has a chance to wake up.
      (sleep 0.1))
    (mp:process-kill tester)))
</pre>

<p>... or external state...</p>

<pre>
(defun flush-entries-from-file (file reporting-stream)
  (loop
   ;; Wait for given file to exist on disk.
   (mp:process-wait (format nil "Waiting for ~a" file)
                    'probe-file file)
   ;; Empty the file to the reporting-stream, being careful to
   ;; allow more contents to accumulate while this is happening.
   (format reporting-stream "~&amp;Reading ~a:~%" file)
   (let ((temp-file (format nil "~a.temp" file)))
     (rename-file file temp-file)
     (with-open-file (istream temp-file)
       (loop (let ((line (read-line istream nil)))
               (unless line
                 (return))
               (write-line line reporting-stream))))
     (delete-file temp-file))))

(defun test-flush-entries-from-file ()
  (delete-file *test-file*)
  (let ((tester
         (mp:process-run-function "Test reading entries from file" ()
                                  'flush-entries-from-file
                                  *test-file*
                                  *standard-output*)))
    ;; Use the previous example to create test data for this test.
    (test-flush-entries-to-log-file)
    (mp:process-kill tester)))
</pre>

<p>Although both of these examples were somewhat contrived, note their
intentions to preserve their data from external modification once the
waiting threads have woken up. In the first example,
<code>shiftf</code> is used to atomically retrieve a symbol-value and
reset it. In the above examples, this level of care didn't
particularly matter, but in some applications it may be important to
keep threads from trampling on each other's data.</p>

<p>Note also the use of <code>mp:process-kill</code> to terminate
unwanted threads when each test is complete.</p>

<a name="initializing"></a><h3>Initializing multithreading</h3>

<p><i>under construction</i></p>


<hr />
<a href="license.html">Copyright</a> &copy; 2002 The Common Lisp Cookbook Project
<address>http://cl-cookbook.sourceforge.net/</address>
<br />
<p><a href="http://validator.w3.org/check/referer"><img
src="http://www.w3.org/Icons/valid-xhtml10" alt="Valid XHTML 1.0!"
height="31" width="88" /></a></p>
<p>$Header: /cvsroot/cl-cookbook/cl-cookbook/process.html,v 1.8 2002/06/26 14:42:03 nicklevine Exp $</p>
</body> </html>
